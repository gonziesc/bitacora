{"data":{"site":{"siteMetadata":{"title":"Bitácora 📚","author":"pdep"}},"markdownRemark":{"id":"3b8a49a7-32b0-593b-ba8d-3600b3c00df9","excerpt":"Tarea para la clase que viene: Terminar todas las lecciones de  Mumuki ¿Qué vimos hoy? Recursividad Fold Simulacro de parcial Recursividad ¿Qué es la…","html":"<h2 id=\"tarea-para-la-clase-que-viene\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene:</h2>\n<p>Terminar todas las lecciones de <a href=\"https://mumuki.io/pdep-utn/chapters/315-programacion-funcional\">Mumuki</a></p>\n<h2 id=\"¿qué-vimos-hoy\"><a href=\"#%C2%BFqu%C3%A9-vimos-hoy\" aria-label=\"¿qué vimos hoy permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Qué vimos hoy?</h2>\n<ul>\n<li>Recursividad</li>\n<li>Fold</li>\n<li>Simulacro de parcial</li>\n</ul>\n<h2 id=\"recursividad\"><a href=\"#recursividad\" aria-label=\"recursividad permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursividad</h2>\n<p>¿Qué es la recursividad? La recursividad es como la recursividad. Claro, pero… ¿Qué es la recursividad? La recursividad es como la recursividad. Claro, pero… ¿Qué es la recursividad? 😝</p>\n<p>La <strong>recursividad</strong> es cuando a una función la definimos en términos de sí misma 🔄. En otras palabras, cuando se invoca a la función dentro de sí misma.</p>\n<p>¿Te acordás alguna función recursiva? Si rebobinás ⏪ hasta AM1 seguro te acuerdes de:</p>\n<p>Factorial ❗\nFibonacci 🐌</p>\n<p>¿Y cómo las codificamos en Haskell?</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorial</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token hvariable\">factorial</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">factorial</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></span></code></pre></div>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token hvariable\">fibonacci</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></span></code></pre></div>\n<p>En las dos soluciones podemos observar que hay <strong>como mínimo</strong>: 👀\nUn <strong>caso recursivo</strong>, en el cual la función se llama a sí misma.\nUn <strong>caso base</strong>, el cual permite cortar la recursividad.</p>\n<p>Ahora que sabemos recursividad veamos cómo podemos definir algunas funciones que ya conocemos de listas:</p>\n<table>\n<thead>\n<tr>\n<th>Forma infija</th>\n<th>Forma prefija</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">sum [] = 0</code></td>\n<td><code class=\"language-text\">sum [] = 0</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">sum (x:xs) = x + sum xs</code></td>\n<td><code class=\"language-text\">sum (x:xs) = (+) x (sum xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">product [] = 1</code></td>\n<td><code class=\"language-text\">product [] = 1</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">product (x:xs) = x * product xs</code></td>\n<td><code class=\"language-text\">product (x:xs) = (*) x (product xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">and [] = True</code></td>\n<td><code class=\"language-text\">and [] = True</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">and (x:xs) = x &amp;&amp; and xs</code></td>\n<td><code class=\"language-text\">and (x:xs) = (&amp;&amp;) x (and xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">or [] = False</code></td>\n<td><code class=\"language-text\">or [] = False</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">or (x:xs) = x || or xs</code></td>\n<td><code class=\"language-text\">or (x:xs) = (||) x (or xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">concat [] = []</code></td>\n<td><code class=\"language-text\">concat [] = []</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">concat (x:xs) = x ++ concat xs</code></td>\n<td><code class=\"language-text\">concat (x:xs) = (++) x (concat xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">aplicar v [] = v</code></td>\n<td><code class=\"language-text\">aplicar v [] = v</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">aplicar v (x:xs) = x $ aplicar v xs</code></td>\n<td><code class=\"language-text\">aplicar v (x:xs) = ($) x (aplicar v xs)</code></td>\n</tr>\n</tbody>\n</table>\n<p>Como podrás ver estamos repitiendo lógica y, <a href=\"https://www.youtube.com/watch?v=8ktYyme_sUw\">¿qué pasa cuando repetimos lógica?</a></p>\n<p>En todas estas funciones:\nEn el caso base nuestra función recibe la lista vacía (<code class=\"language-text\">[ ]</code>) y devuelve un <em>valor inicial</em>.\nEn el caso recursivo siempre tenemos a una operación que recibe:\nLa cabeza de la lista.\nLa llamada recursiva de la función que estamos definiendo con la cola como parámetro.</p>\n<p>¿Y cómo quitamos toda esta lógica repetida? 😱 ¡Parametrizando!</p>\n<h2 id=\"fold\"><a href=\"#fold\" aria-label=\"fold permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fold</h2>\n<p>Para salvarnos de la repetición de lógica tenemos a nuestro gran amigo el <a href=\"https://docs.google.com/document/d/1jSrU7lVMan4nbHBETGqvO5VpqJI0KXVWtH7fqnVASPU/edit\">fold</a>. Ahora a nuestro <em>valor inicial</em> que se re repetía en todas nuestras funciones lo llamaremos <code class=\"language-text\">semilla</code>y al operador del caso recursivo lo llamaremos, simplemente, <code class=\"language-text\">funcion</code> . 😜</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldr</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">semilla</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldl</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>     <span class=\"token operator\">=</span>  <span class=\"token hvariable\">semilla</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<p>Peeeero, ¿qué pasa si queremos averiguar el máximo (o mínimo) valor dentro de una lista? ¿Qué puedo usar como semilla? 🌰</p>\n<p>Para los casos en los cuales no sabemos qué semilla utilizar, tenemos a <code class=\"language-text\">foldl1</code> que usa el primer elemento de las lista como semilla:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldl1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span><span class=\"token hvariable\">a</span><span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n<span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Como verás <code class=\"language-text\">foldl1</code>, a diferencia de <code class=\"language-text\">foldl</code> y <code class=\"language-text\">foldr</code>, no funciona con listas vacías.</p>\n<p>Te invitamos a que pruebes en tu consola cómo funciona la familia foldl. 😄</p>\n<h2 id=\"simulacro-de-parcial\"><a href=\"#simulacro-de-parcial\" aria-label=\"simulacro de parcial permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Simulacro de parcial</h2>\n<p>En lo que quedo de la clase estuvimos haciendo este <a href=\"/bitacora/parcial-funcional-tierra-de-barbaros-ff24d36187ac71de684aeb1c935a6fc5.pdf\">parcial</a> y como no llegamos a hacer una puesta en común les dejamos <a href=\"/bitacora/solucionParcialBarbaros-5dbe1ebff0d93095a854e498be8fc010.hs\">esta posible solución</a></p>\n<h2 id=\"links-útiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links útiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links útiles:</h2>\n<p><a href=\"http://wiki.uqbar.org/wiki/articles/recursividad-en-haskell.html\">Recursividad</a>\n<a href=\"http://wiki.uqbar.org/wiki/articles/fold.html\">Foldl</a>\n<a href=\"https://www.youtube.com/watch?v=veiQkxz59NE\">Video de foldl del gran profesor Alf</a></p>","frontmatter":{"title":"Séptima clase","date":"29-04-2019","description":"‘Recursividad, Fold'","tags":["funcional","recursividad","fold"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/funcional/clase-07/","previous":{"fields":{"slug":"/funcional/clase-06/"},"frontmatter":{"title":"Sexta clase"}},"next":null}}